<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Parameters
CELL_SIZE = sprite_get_width(sp_cell);
GRID_WIDTH = 10;
GRID_HEIGHT = 10;

// Globals
global.collisions = 0;
global.end_time = 0;

// Member variables
start_time = round(current_time / 1000);

// Local variables
var to_visit = 0;
var visit_stack;
var i;
var row;
var col;
var cell_id;
var current_x;
var current_y;
var current_cell_id;
var to_visit_cell_id;
var neighbor_cell_id;
var random_neighbor_index;
var travel_dir = -1; // 0 is north, 1 is east, 2 is south, 3 is west

// Create list
neighbor_list = ds_list_create();

// Create stack
visit_stack = ds_stack_create();

// Random seed
randomize();

instance_create(room_width / 2 + (-GRID_WIDTH / 2) * CELL_SIZE, room_height / 2 + (-GRID_HEIGHT / 2) * CELL_SIZE, obj_mouse);
instance_create(room_width / 2 + (GRID_WIDTH / 2) * CELL_SIZE, room_height / 2 + (GRID_HEIGHT / 2) * CELL_SIZE, obj_exit);

// Set default mouse location
window_mouse_set(room_width / 2 + (-GRID_WIDTH / 2) * CELL_SIZE, room_height / 2 + (-GRID_HEIGHT / 2) * CELL_SIZE);

// Create initial grid
for (row = -GRID_HEIGHT / 2; row &lt;= GRID_HEIGHT / 2; row++)
{
    for (col = -GRID_WIDTH / 2; col &lt;= GRID_WIDTH / 2; col++)
    {
        cell_id = instance_create(room_width / 2 + col * CELL_SIZE, room_height / 2 + row * CELL_SIZE, obj_cell);
    }    
}
to_visit = (GRID_HEIGHT + 1) * (GRID_WIDTH + 1);

// Select starting point
current_x = room_width / 2;
current_y = room_height / 2;

// Initialize first cell selection, future cells selections will be done with reference to a previously visited cell
current_cell_id = instance_position(current_x, current_y, obj_cell);
current_cell_id.visited = true;
to_visit--;

// Create the maze
while (to_visit &gt; 0)
{   
    current_x = current_cell_id.x;
    current_y = current_cell_id.y;

    // Check if surrounding cells visited
    ds_list_clear(neighbor_list);
    for (i = 0; i &lt; 4; i++)
    {
        switch (i)
        {
            case 0:
                neighbor_cell_id = instance_position(current_x + CELL_SIZE, current_y, obj_cell);
                break;
            case 1:
                neighbor_cell_id = instance_position(current_x - CELL_SIZE, current_y, obj_cell);
                break;
            case 2:
                neighbor_cell_id = instance_position(current_x, current_y - CELL_SIZE, obj_cell);
                break;
            case 3:
                neighbor_cell_id = instance_position(current_x, current_y + CELL_SIZE, obj_cell);
                break;
        }
        if (neighbor_cell_id != noone &amp;&amp; !neighbor_cell_id.visited) // Check if cell to visit is within grid and not alraedy visited
            ds_list_add(neighbor_list, neighbor_cell_id);
    }
    
    // Find next cell to visit
    if (ds_list_empty(neighbor_list)) // All neighbors visited
    {
        if (ds_stack_empty(visit_stack))
            show_error("Stack empty, no cell to visit", true);
        else
            current_cell_id = ds_stack_pop(visit_stack);
    }
    else // At least one surrounding neighbor has not been visited
    {
        random_neighbor_index = irandom(ds_list_size(neighbor_list) - 1);
        to_visit_cell_id = ds_list_find_value(neighbor_list, random_neighbor_index);
        
        // Destroy the wall between current cell and to_visit cell
        if (to_visit_cell_id.x &gt; current_cell_id.x) // Moved right
        {
            with (current_cell_id.right_wall)
                instance_destroy();
            with (to_visit_cell_id.left_wall)
                instance_destroy();
        }
        else if (to_visit_cell_id.x &lt; current_cell_id.x) // Moved left
        {
            with (current_cell_id.left_wall)
                instance_destroy();
            with (to_visit_cell_id.right_wall)
                instance_destroy();
        }
        else if (to_visit_cell_id.y &gt; current_cell_id.y) // Moved down
        {
            with (current_cell_id.bot_wall)
                instance_destroy();
            with (to_visit_cell_id.top_wall)
                instance_destroy();
        }
        else if (to_visit_cell_id.y &lt; current_cell_id.y) // Moved up
        {
            with (current_cell_id.top_wall)
                instance_destroy();
            with (to_visit_cell_id.bot_wall)
                instance_destroy();
        }
        
        // Put current cell id in stack to trace back later
        ds_stack_push(visit_stack, current_cell_id);
        
        // Make current cell the cell to visit
        current_cell_id = to_visit_cell_id;
        
        if (current_cell_id.visited)
            show_error("Cell already visited", true);
        
        current_cell_id.visited = true;
        to_visit--;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (room == 1)
{
    draw_set_font(fnt_big);
    draw_text(room_width / 8, room_height / 4, "Total collisions: " + string(global.collisions));
    draw_text(room_width / 8, room_height / 2, "Elapsed Time: " + string(global.end_time - start_time) + " seconds");
}
else // Debug
    draw_text(0, 0, string(global.collisions));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
